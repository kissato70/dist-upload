#!/bin/bash

# **************************************************************************************************************************
#  Configurator script for AWS S3 bucket upload from the distribution folder
#
#  Command:  dist-upload [params]
#
#  Optional params:
#   -c    (configFile)          The name of the config file to save (-w) or use. [aws.distconfig]
#   -w                          Config file write mode, for creating configuration(s).
#   -p    (profileName)         Sets the AWS profile name. [default]
#   -r    (regionName)          Sets the AWS region name for the profile. [us-east-1]
#   -a    (accessKey)           Sets the AWS IAM user's access_key for the profile.
#   -s    (secretKey)           Sets the AWS IAM user's secret_access_key for the profile.
#   -g    (true|[false])        Should the name of the config file be added to .gitignore file.
#   -d    (distDirectory)       Sets the distribution directory. [dist]
#   -b    (bucketName)          Sets the AWS S3 bucket name in config.
#   -i    (bucketName|off)      Sets the AWS S3 bucket name for incremental release backup in config.
#   -R                          Rollback (undo) release: Rolls back the code to previsous state, deleting the last release.
#   -m    (versionLimit)        The maximum number of versions kept in the bucket. Older will be deleted.
#   -f    (branchFolder)        The folder for automated version storage. You can store different branches this way.
#   -l    [tailNumber]          Lists [the last n number of] the release versions in the incremental backup bucket.
#   -y                          Answers default option to the config questions. Hint: use for changing only the given params.
#   -S                          Silent mode. Hides all the information about the process.
#
#  Written by: Attila Kiss, e-LET Kft, Hungary  ( GitHub: kissato70 )
#  Licence:  MIT
# **************************************************************************************************************************

# Setting base variables
VERSION="1.1.0"
BASE_DIR=$(dirname "$0")
NAME_PATTERN="^[A-Za-z][A-Za-z0-9\-\_]+[A-Za-z]$" # regexp pattern for name checking
CONFIG_FILE_NAME_DEFAULT="upload"    # Default name for the config file to save.
CONFIG_FILE_TYPE="dist.config"             # Config file ending.
CONFIG_FILE_DIR="."                       # Place the config file in this folder.
DIST_DIR_DEFAULT="dist"                   # Default value for the folder name to send to S3.
#DEFAULT_BACKUP_BUCKET="off"              # Backup is switched off as default.
DEFAULT_BRANCH_FOLDER="Main"              # Branch name folder name in the backup bucket ("Branch/{versionName}")
DEFAULT_VERSION_LIMIT=0
LIST_MODE=false
DEFAULT_LIST_TAIL=0
SILENT_MODE=false;

echoS () {
  if [ ! "$SILENT_MODE" = true ] && [ ! "$LIST_MODE" = true  ]; then
    echo "$1"
  fi
}

# Default values for AWS config
DEFAULT_PROFILE="default"
DEFAULT_BUCKET=""

# Reading out the optional flags
while getopts ":c:wp:d:b:r:a:s:g:yi:m:f:l:R:S" flag
do
    case "${flag}" in
        c)  CONFIG_FILE_NAME=$OPTARG;;
        w)  CONFIG_FILE_WRITE_MODE=true;;
        p)  PROFILE=$OPTARG;;
        r)  AWS_REGION=$OPTARG;;
        a)  ACCESS_KEY=$OPTARG;;
        s)  SECRET_KEY=$OPTARG;;
        g)  GITIGNORE=$OPTARG;;
        d)  DIST_DIR=$OPTARG;;
        b)  S3_BUCKET=$OPTARG;;
        i)  BACKUP_BUCKET=$OPTARG;;
        m)  VERSION_LIMIT=$OPTARG;;
        f)  BRANCH_FOLDER=$OPTARG;;
        l)  LIST_TAIL=$OPTARG
            LIST_MODE=true
            ;;
        S)  #if test "$OPTARG" = "$(eval echo '$'$((OPTIND - 1)))"; then
            #  OPTIND=$((OPTIND - 1))
            #fi
            SILENT_MODE=true;;
        R)  ROLLBACK=true;;
        y)  YES="true";;
        :)  case "$OPTARG" in
              i) BACKUP_BUCKET="off";;
              l) LIST_MODE=true;;
              R) ROLLBACK=true;;
              S) SILENT_MODE=true;
              OPTIND=$((OPTIND - 1))
            esac ;;
    esac
done

echoS "---------------------------------------------------------------------"
echoS "|                      S3 upload-dist $VERSION                         |"
echoS "---------------------------------------------------------------------"

# Check if aws-cli is installed
if command -v aws 2>&1 | grep -q 'aws' ; then
  :
else
  echo "ERROR: The aws-cli installation is missing."; exit 1
fi


# CONFIG SECTION ******************************************************************************

# If config file is set in params, use it, otherwise go on with default
if [ -z "$CONFIG_FILE_NAME" ]; then
    CONFIG_FILE_NAME=$CONFIG_FILE_NAME_DEFAULT
fi
if [ "$CONFIG_FILE_WRITE_MODE" = true ] ; then
  # If only write mode is set (no config name is given)  then overwrite 
  # Cecking and setting the config file name (letters and numbers only)
  if [[ ! $CONFIG_FILE_NAME =~ $NAME_PATTERN ]]; then
    echo "ERROR : Invalid config file name ($CONFIG_FILE_NAME): only letters and numbers allowed!"; exit 1
  fi
else
  if [ -z "$CONFIG_FILE_NAME" ]; then
    CONFIG_FILE_NAME=$CONFIG_FILE_NAME_DEFAULT
  else
    CONFIG_FILE_NAME_DEFAULT=$CONFIG_FILE_NAME
  fi
  echoS "Using config file: $CONFIG_FILE_NAME"
fi

CONFIG_FILE="$CONFIG_FILE_DIR/$CONFIG_FILE_NAME.$CONFIG_FILE_TYPE"
# If the config file exists, read its contents
if [ -f "$CONFIG_FILE" ]; then
  echoS "Reading in config file: $CONFIG_FILE_NAME"
  while IFS= read -r ROW
  do
    params=(${ROW//=/ })
    case "${params[0]}" in
      AWS_PROFILE)
        DEFAULT_PROFILE=${params[1]}
        ;;
      DIST_DIR)
        DIST_DIR_DEFAULT=${params[1]}
        ;;
      S3_BUCKET)
        DEFAULT_BUCKET=${params[1]}
        ;;
      BACKUP_BUCKET)
        DEFAULT_BACKUP_BUCKET=${params[1]}
      ;;
      BRANCH)
        DEFAULT_BRANCH_FOLDER=${params[1]}
      ;;
      VERSION_LIMIT)
        DEFAULT_VERSION_LIMIT=${params[1]}
      ;;
    esac
  done < "$CONFIG_FILE"
else
  if [ "$CONFIG_FILE_WRITE_MODE" = false ]; then
    echo "ERROR: Config file ($CONFIG_FILE_NAME) not found!"; exit 1
  fi
fi

# If the config write param is set and the file already exists, confirm to overwrite
if [ "$CONFIG_FILE_WRITE_MODE" = true ] && [ -f "$CONFIG_FILE" ] ; then
  if [ -z "$YES" ] ; then
    read -rp "AWS config file already exists, do you want to overwrite it? (y/N): " confirm && [[ $confirm == [yY] || $confirm == [yY][eE][sS] ]] || exit 1
  fi
fi
if [ "$CONFIG_FILE_WRITE_MODE" = true ]; then
  echoS "Writing to config file: $CONFIG_FILE_NAME"
fi

# If not previously set, ask for which of the AWS (named)profiles to use
if [ "$CONFIG_FILE_WRITE_MODE" = false ] && [ -z "$PROFILE" ]; then
  PROFILE=$DEFAULT_PROFILE
fi
if [ "$CONFIG_FILE_WRITE_MODE" = true ] && [ -z "$PROFILE" ] && [ -z "$YES" ]; then
  read -p "AWS profile name [$DEFAULT_PROFILE]:" PROFILE
fi
if [ -z "$PROFILE" ]; then
  PROFILE=$DEFAULT_PROFILE
fi

# Checking the given profile name
if [[ $PROFILE =~ ^[A-Za-z][A-Za-z0-9]+$ ]]; then
  echoS "  Using named profile: $PROFILE"
else
  echo "ERROR: Invalid profile name ($PROFILE): only letters and numbers are allowed, with a starting character."; exit 1;
fi

# Set the region and keys if present
if [ -z "$AWS_REGION" ]; then
  :
else
  if aws configure set region $AWS_REGION --profile $PROFILE 2>&1 | grep -q 'error'; then
    echo "Error at setting the region name ($AWS_REGION)!"; exit 1
  else
    echoS "Region ($AWS_REGION) has been set for profile ($PROFILE)."
  fi
fi
if [ -z "$ACCESS_KEY" ]; then
  :
else
  if aws configure set aws_access_key_id $ACCESS_KEY --profile $PROFILE 2>&1 | grep -q 'error'; then
    echo "ERROR: Error at setting the access key ($ACCESS_KEY)!"; exit 1
  else
    echoS "Access key ($ACCESS_KEY) has been set for profile ($PROFILE)."
  fi
fi
if [ -n "$SECRET_KEY" ]; then
  if aws configure set aws_secret_access_key $SECRET_KEY --profile $PROFILE 2>&1 | grep -q 'error'; then
    echo "ERROR: Error at setting the secret key (*** ${SECRET_KEY: (-4)})!"; exit 1
  else
    echoS "Secret key (*** ${SECRET_KEY: (-4)}) has been set for profile ($PROFILE)."
  fi
fi

# Checking whether the profile exists
if [[ $(aws configure --profile $PROFILE list ) && $? -eq 0 ]]; then
  : # nothing to do
else
    # If in write mode, running the AWS configure command, quiting if it has failed
    if [ "$CONFIG_FILE_WRITE_MODE" = true ] ; then
      echo "Profile ($PROFILE) cannot be found, running the AWS configure command to set it up."
      aws configure --profile $PROFILE || exit 1 && echo "AWS configuration saved."
    else
      echo "ERROR: AWS profile ($PROFILE) cannot be found!"; exit 1
    fi
fi

# Setting the dist directory if it is not set already
if [ "$CONFIG_FILE_WRITE_MODE" = false ] && [ -z "$DIST_DIR"  ]; then
    DIST_DIR=$DIST_DIR_DEFAULT
fi
if [ "$CONFIG_FILE_WRITE_MODE" = true ] && [ -z "$DIST_DIR" ] && [ -z "$YES" ]; then
  read -p "Dist directory [$DIST_DIR_DEFAULT]: " DIST_DIR
fi
if [ -z "$DIST_DIR" ]; then
  DIST_DIR=$DIST_DIR_DEFAULT
fi
if [[ $DIST_DIR =~ $NAME_PATTERN ]]; then
  echoS "  Using distribution directory: $DIST_DIR"
else
  echo "ERROR: Invalid dist directory name ($DIST_DIR): only letters and numbers allowed!"; exit 1
fi

if [ ! -d "$DIST_DIR" ]; then
  echo "ERROR: The distribution folder ($DIST_DIR) does not exists!"; exit 1
fi

# If not previously set, getting the S3 bucket name
if [ "$CONFIG_FILE_WRITE_MODE" = false ] && [ -z "$S3_BUCKET" ]; then
    S3_BUCKET=$DEFAULT_BUCKET
fi
if [ -z "$YES" ] || [ -z "$DEFAULT_BUCKET" ]; then
  if [ "$CONFIG_FILE_WRITE_MODE" = true ] && [ -z "$S3_BUCKET" ]; then
    if [ -n "$DEFAULT_BUCKET" ]; then
      read -p "Amazon S3 bucket name [$DEFAULT_BUCKET]: " S3_BUCKET
    else
      read -p "Amazon S3 bucket name: " S3_BUCKET
    fi
  fi
fi
if [ -z "$S3_BUCKET" ]; then
  S3_BUCKET=$DEFAULT_BUCKET
fi
# Checking the given bucket name format
if [[ "$S3_BUCKET" =~ ^[a-z][a-z0-9\-]+[a-z0-9]+$ ]]; then
  echoS "  Using S3 bucket: $S3_BUCKET"
else
  echo "ERROR: Invalid bucket name!"; exit 1;
fi

# If in write mode, then perform some tests
if [ "$CONFIG_FILE_WRITE_MODE" = true ] ; then
  # Checking whether the bucket exists on S3 and reachable with the given profile
  if aws s3 ls $S3_BUCKET --profile $PROFILE  2>&1 | grep -q 'NoSuchBucket' ; then
    echo "ERROR: The given S3 bucket '$S3_BUCKET' does not exists or not reachable with the credentials set in the profile '$PROFILE' !"; exit 1
  else
    echoS "    Bucket exists."
  fi
  # Checking write permission on bucket
  TEST_FILE="AWS_dist_configure_write_access_test.file"
  echo "AWS distribution write access TEST FILE - If you read this, you can delete this file any time." > $BASE_DIR/$TEST_FILE 
  if aws s3 cp $BASE_DIR/$TEST_FILE  s3://$S3_BUCKET --profile $PROFILE  2>&1 | grep -q 'error' ; then
    echo "ERROR: Bucket write test has failed. Check the permissions of the user!"; exit 1
  else
    # Clean up backup file
    aws s3 rm s3://$S3_BUCKET/$TEST_FILE --profile $PROFILE > /dev/null 2>&1
    echoS "    Bucket is verified."
  fi
  # Clean up local file
  rm $BASE_DIR/$TEST_FILE
fi  # testing if in write mode

# If backup bucket is set or given as a param, check and set it too
if [ "$CONFIG_FILE_WRITE_MODE" = false ] && [ -z BACKUP_BUCKET ] ; then
  BACKUP_BUCKET=$DEFAULT_BACKUP_BUCKET
fi
if [ -z "$YES" ] || [ -z "$DEFAULT_BACKUP_BUCKET" ]; then
  if [ "$CONFIG_FILE_WRITE_MODE" = true ] && [ -z "$BACKUP_BUCKET" ]; then
    if [ -n "$DEFAULT_BACKUP_BUCKET" ]; then
      read -p "Backup bucket name [$DEFAULT_BACKUP_BUCKET] or use 'off' for none: " BACKUP_BUCKET
    else
      read -p "Backup bucket name: " BACKUP_BUCKET
    fi
  fi
fi
if [ -z "$BACKUP_BUCKET" ]; then
  BACKUP_BUCKET=$DEFAULT_BACKUP_BUCKET
fi
# If not switched off  and its name differs from main bucket, check it (if in write mode)
if [ -n "$BACKUP_BUCKET" ] && [ "$BACKUP_BUCKET" != "$S3_BUCKET" ]  && [ "$BACKUP_BUCKET" != "off"  ] && [ "$CONFIG_FILE_WRITE_MODE" = true ] ; then
  # Checking the given bucket name format
  if [[ "$BACKUP_BUCKET" =~ ^[a-z][a-z0-9\-]+[a-z0-9]+$ ]]; then
    echoS "  Using S3 bucket for backup: $BACKUP_BUCKET"
  else
    echo "ERROR: Invalid backup bucket name ($BACKUP_BUCKET)!"; exit 1;
  fi
  # Checking whether the bucket exists on S3 and reachable with the given profile
  if aws s3 ls $BACKUP_BUCKET --profile $PROFILE  2>&1 | grep -q 'NoSuchBucket' ; then
    echo "ERROR: The given S3 backup bucket '$BACKUP_BUCKET' does not exists or not reachable with the credentials set in the profile '$PROFILE' !"; exit 1
  else
    echoS "    Backup bucket exists."
  fi
  # Checking write permission on bucket
  TEST_FILE="AWS_dist_configure_write_access_test.file"
  echo "Write TEST FILE - If you read this, you can delete this file any time." > $BASE_DIR/$TEST_FILE
  if aws s3 cp $BASE_DIR/$TEST_FILE  s3://$BACKUP_BUCKET --profile $PROFILE  2>&1 | grep -q 'error' ; then
    echo "Bucket write test has failed. Check the permissions of the user!"; exit 1
  else
    # Clean up bucket file
    aws s3 rm s3://$BACKUP_BUCKET/$TEST_FILE --profile $PROFILE > /dev/null 2>&1
    # We need to check, whether the bucket is free of files (it can mess up the bucket otherwise)
    BUCKET_CONTENT=`aws s3 ls --profile $PROFILE s3://$BACKUP_BUCKET | grep -v "/"`
    if [ -n "$BUCKET_CONTENT" ]; then
      echo "ERROR: Bucket is not empty! Only an empty bucket can be used for backup location."; exit 1
    fi
    echoS "    Backup bucket is verified."
  fi
  # Clean up local file
  rm $BASE_DIR/$TEST_FILE
else
  if [ "$CONFIG_FILE_WRITE_MODE" = true  ] && [ "$BACKUP_BUCKET" == "off" ] ; then
    echoS "  Backup is switched OFF."
  fi
fi

# Setting the branch if it is not set already (and backup is not set to 'off')
  if [ "$CONFIG_FILE_WRITE_MODE" != true ] && [ -z "$BRANCH_FOLDER" ]; then
      BRANCH_FOLDER=$DEFAULT_BRANCH_FOLDER
  fi

# If ROLLBACK mode selected or backup is switched off, then leave this part out
if [ "$ROLLBACK" != true ] && [ "$BACKUP_BUCKET" != 'off'  ]; then

  if [ "$CONFIG_FILE_WRITE_MODE" = true ] && [ -z "$BRANCH_FOLDER" ] && [ -z "$YES" ]; then
    read -p "Release branch [$DEFAULT_BRANCH_FOLDER]: " BRANCH_FOLDER
  fi
  if [ -z "$BRANCH_FOLDER" ]; then
    BRANCH_FOLDER=$DEFAULT_BRANCH_FOLDER
  fi
  if [[ ! $BRANCH_FOLDER =~ $NAME_PATTERN ]]; then
    echo "ERROR: Invalid branch name ($BRANCH_FOLDER): only letters and numbers allowed!"; exit 1
  else
    echoS "  Using branch: $BRANCH_FOLDER"
  fi

  # Setting the version max number (and backup is not set to 'off')
  if [ "$CONFIG_FILE_WRITE_MODE" = false ] && [ -z "$VERSION_LIMIT" ]; then
      VERSION_LIMIT=$DEFAULT_VERSION_LIMIT
  fi
  if [ "$CONFIG_FILE_WRITE_MODE" = true ] && [ -z "$VERSION_LIMIT" ] && [ -z "$YES" ]; then
    read -p "Max count of branch version to keep in backup [$DEFAULT_VERSION_LIMIT] or '0' for unlimited: " VERSION_LIMIT
  fi
  if [ -z "$VERSION_LIMIT" ]; then
    VERSION_LIMIT=$DEFAULT_VERSION_LIMIT
  fi
  VERSION_PATTERN="^[0-9]+$"
  if [[ ! $VERSION_LIMIT =~ $VERSION_PATTERN ]]; then
    echo "ERROR: Invalid max version limit ($VERSION_LIMIT): only numbers allowed!"; exit 1
  else
    echoS "  Using maximum branch version limit: $VERSION_LIMIT"
  fi

  # If in write mode, then writing out the configuration
  if [ "$CONFIG_FILE_WRITE_MODE" = true ] ; then
    echo "" > "$CONFIG_FILE"    # first emptying the file
    echo "AWS_PROFILE=$PROFILE" >> $CONFIG_FILE
    echo "DIST_DIR=$DIST_DIR" >> $CONFIG_FILE
    echo "S3_BUCKET=$S3_BUCKET" >> $CONFIG_FILE
    echo "BACKUP_BUCKET=$BACKUP_BUCKET" >> $CONFIG_FILE
    echo "BRANCH=$BRANCH_FOLDER" >> $CONFIG_FILE
    echo "VERSION_LIMIT=$VERSION_LIMIT" >> $CONFIG_FILE
    # Adding the config file to .gitignore
    if [ "$GITIGNORE" == "true" ]; then
      if [ -f $BASE_DIR/.gitignore ]; then
        if grep -q *.$CONFIG_FILE_TYPE $BASE_DIR/.gitignore 2>&1 ; then
          :
        else
          echo "" >> $BASE_DIR/.gitignore
          echo "# distribution config file" >> $BASE_DIR/.gitignore
          echo "*.$CONFIG_FILE_TYPE"  >> $BASE_DIR/.gitignore
          echo "" >> $BASE_DIR/.gitignore
          echo "The config file type is added to the .gitignore file."
        fi
      else
        echoS "If you will use Git in the future, you may add $CONFIG_FILE_NAME or *.$CONFIG_FILE_TYPE to your .gitignore file."
      fi
    fi
    # Give a note about how to use the command with the config
    CCONFIG=""
    if [ "$CONFIG_FILE_NAME" != "$CONFIG_FILE_NAME_DEFAULT" ]; then
      CCONFIG=" -c $CONFIG_FILE_NAME"
    fi

    echoS ""
    echo  "- Config file saved. -"
    echoS ""
    echoS "For uploading your site, you can use now the command:  dist-upload$CCONFIG"
    echoS ""
    exit 0
  fi

fi # not ROLLBACK mode


# SYNC SECTION *********************************************************************************

# Checking whether the bucket exists on S3 and reachable with the given profile
if aws s3 ls $S3_BUCKET --profile $PROFILE  2>&1 | grep -q 'NoSuchBucket' ; then
  echo "ERROR: The given S3 bucket ($S3_BUCKET) does not exists or not reachable with the credentials set in the profile '$PROFILE!'"; exit 1
else
  if [ ! "$LIST_MODE" = true ]; then
    if [ ! "$ROLLBACK" = true ]; then
      echoS ""
      echoS "Starting the sync..."
    else
      echoS "  Using backup bucket: $BACKUP_BUCKET"
      echoS ""
      echoS "Starting the recovery of the previous distribution version..."
    fi
  fi
fi
# If backup bucket is not set, use the one read from settings file
if [ -z "$BACKUP_BUCKET" ]; then
  BACKUP_BUCKET=$DEFAULT_BACKUP_BUCKET
fi

# If list mode is active, but backup is switched off, drop a note
if [ "$LIST_MODE" = true ] && [ "$BACKUP_BUCKET" == "off"  ]; then
  echoS "The backup versioning is switched off."; exit 0
fi

# If it is not switched off, start the process of backup
if [ "$BACKUP_BUCKET" != "off" ] ; then
    # Check whether the backup bucket exists
    if aws s3 ls $BACKUP_BUCKET --profile $PROFILE  2>&1 | grep -q 'NoSuchBucket' ; then
      echo "ERROR: The given backup bucket ($BACKUP_BUCKET) does not exists or not reachable with the credentials set in the profile '$PROFILE!'"; exit 1
    fi
    # Reading in existing release names
    VERSIONS=`aws s3 ls --profile $PROFILE s3://$BACKUP_BUCKET/$BRANCH_FOLDER/  | cut -c32- | grep / | tr -s '\n' ' '`
    VERSION_COUNT=0
    # If there are any versions, count them
    if [ -n "$VERSIONS" ]; then
        for VERS in $VERSIONS
        do
          VERSION_COUNT=$((VERSION_COUNT+1))
        done
    fi

    # If list mode is active, show the branch contents
    if [ "$LIST_MODE" = true ]; then
      if [ -z $LIST_TAIL ]; then
        LIST_TAIL=$DEFAULT_LIST_TAIL
      fi
      echo "Bucket '$BACKUP_BUCKET/$BRANCH_FOLDER':"
      VERS_INDEX=0
      VERS_FIRST_INDEX=$((VERSION_COUNT-LIST_TAIL+1))
      for FOLDER in $VERSIONS
        do
          VERS_INDEX=$((VERS_INDEX+1))
          if [ "$LIST_TAIL" -eq 0 ] || [ "$VERS_INDEX" -ge "$VERS_FIRST_INDEX"  ]; then
            echo "  `echo $FOLDER | sed 's/.$//'`"
          fi
        done
      if [ "$LIST_TAIL" -eq 0 ]; then
        echo "--- Total: $VERSION_COUNT version(s) ---"
        echoS ""
      fi
      exit 0
    fi  # list mode

    # If the limit is not set to 0 (swithed off limit check)
    if [ -n "$VERSION_LIMIT" ]; then
      if [ "$VERSION_LIMIT" -gt 0 ]; then
        TO_DELETE=""
        # If the branch is not empty, select the overhead versions
        if [ -n "$VERSIONS" ]; then
          VERSION_INDEX=0
          VERSION_OLD=$((VERSION_COUNT-VERSION_LIMIT+1))
          if [ "$VERSION_OLD" -gt 0 ]; then
            for VERS in $VERSIONS
            do
              VERSION_INDEX=$((VERSION_INDEX+1))
              if [ "$VERSION_INDEX" -le "$VERSION_OLD" ]; then
                TO_DELETE="$TO_DELETE $VERS"                    # Add overhead version to the dead list
              fi
            done
          fi
          echoS "  Number of branch versions available in branch '$BRANCH_FOLDER': $VERSION_COUNT"
          # If there are overhead versions, then delete these old ones
          if [ -n "$TO_DELETE" ]; then
            echoS "    Deleting $((`wc -w <<< $TO_DELETE`)) old branch version(s)..."
            for DEL in $TO_DELETE
            do
              echoS "      Deleting : `echo $DEL | sed 's/.$//'`"
              aws s3 rm s3://$BACKUP_BUCKET/$BRANCH_FOLDER/$DEL --recursive  --profile $PROFILE 2>&1  > /dev/null
            done
          fi
        fi
      else
        echoS "  Version limit is switched OFF."
      fi  # limit is not switched off
    fi

    VERSION=`date '+%Y-%m-%d_%H:%M:%S'`

    if [ "$ROLLBACK" != true ]; then
      echoS "  Backing up existing distribution"
      echoS "    Using backup bucket: $BACKUP_BUCKET"
      # Create release version id with branch
      if [ -z "$RELEASE_VERSION" ]; then
        RELEASE_VERSION="$BRANCH_FOLDER/$VERSION"
      fi
      echoS "    Creating release version: $RELEASE_VERSION"
      if aws s3 sync $DIST_DIR s3://$BACKUP_BUCKET/$RELEASE_VERSION/  --delete  --profile $PROFILE  --acl public-read --content-type text/html  2>&1 > /dev/null | grep -q "error" ; then
        echo "ERROR: Backup error: copy from dist folder to backup bucket has failed."; exit 1
      fi
    else    #ROLLBACK mode
      if [ -z "$VERSIONS" ]; then
        echo "ERROR: No version is available to recover."; exit 1
      fi
      # Searching for the last version (to be deleted) and the previous (to be recovered)
      VERS_RECOVER=""
      VERS_DELETE=""
      VERSION_INDEX=0
      for VERS in $VERSIONS
      do
        VERSION_INDEX=$((VERSION_INDEX+1))
        if [ "$VERSION_INDEX" -eq "$VERSION_COUNT" ]; then
          VERS_DELETE=$VERS                    # Add the last version to the dead list
        else
          VERS_RECOVER=$VERS                   # Store the index here, until the last remaining version
        fi
      done
      if [ -z "$VERS_RECOVER" ]; then
        echo "ERROR: No version is available to recover."; exit 1
      fi
      echoS "  Deleting the last version  : `echo $VERS_DELETE | sed 's/.$//'`"
      aws s3 rm s3://$BACKUP_BUCKET/$BRANCH_FOLDER/$VERS_DELETE --recursive  --profile $PROFILE 2>&1  > /dev/null
      echoS "  Recovering previous version: `echo $VERS_RECOVER | sed 's/.$//'`"
      if aws s3 rm s3://$S3_BUCKET/ --recursive --profile $PROFILE 2>&1 > /dev/null | grep -q "error"; then
        $REC_ERROR="Recovery ERROR: Delete bucket content error.";
      fi
      if aws s3 cp s3://$BACKUP_BUCKET/$BRANCH_FOLDER/$VERS_RECOVER s3://$S3_BUCKET/  --recursive  --profile $PROFILE  2>&1 > /dev/null | grep -q "error"; then
        $REC_ERROR="Recovery ERROR: Recovery sync error."
      fi
      if [ -n "$REC_ERROR" ]; then
        echo ""
        echo "///////////////////////////////////////////////"
        echo "//                                           //"
        echo "//                WARNING !                  //"
        echo "//  File sync error, recovery unsuccessful!  //"
        echo "//                                           //"
        echo "///////////////////////////////////////////////";  exit 1
      else
        echoS ""
        echoS "•••••••••••••••••••••••••••••••••"
        echoS "•                               •"
        echoS "•    Rollback is successful.    •"
        echoS "• Version: `echo $VERS_RECOVER | sed 's/.$//'`  •"
        echoS "•                               •"
        echoS "•••••••••••••••••••••••••••••••••"
        if [ "$SILENT_MODE" = true ]; then
          echo "Rollback to version `echo $VERS_RECOVER | sed 's/.$//'`  was successful."
        fi
        exit 0
      fi
    fi

fi # backup == off


# Getting the region from the profile
AWS_REGION=`aws configure get region --profile $PROFILE`

echoS "Syncing $DIST_DIR -> S3://$S3_BUCKET"


# Sync the dist files to S3
if [ "$BACKUP_BUCKET" == "off" ] || [ "$BACKUP_BUCKET" != "$S3_BUCKET"  ]; then
  if aws s3 sync $DIST_DIR s3://$S3_BUCKET --profile $PROFILE --delete --acl public-read --content-type text/html  2>&1 > /dev/null | grep -q "error"; then
    SYNC_ERROR="ERROR: Uploading to bucket has failed."
  fi
else
  if [ "$BACKUP_BUCKET" == "$S3_BUCKET" ]; then
    INDEX_HTML='<html><head><meta http-equiv="Refresh" content="1; URL=./'$RELEASE_VERSION'/index.html"></head></html>'
    echo $INDEX_HTML | aws s3 cp - s3://$S3_BUCKET/index.html --profile $PROFILE --acl public-read --content-type text/html
  fi
fi
if [ -n "$SYNC_ERROR" ]; then
  echo "/////////////////////////////////////////////"
  echo "//                                         //"
  echo "//               WARNING !                 //"
  echo "//  File sync error, upload unsuccessful!  //"
  echo "//                                         //"
  echo "/////////////////////////////////////////////"; echo $SYNC_ERROR;  exit 1
else
  echoS "••••••••••••••••••••••••••••••••••••••••••••••••••••••••"
  echoS "•                                                      •"
  echoS "•  Synchronisation successful. Your site is uploaded.  •"
  echoS "•                                                      •"
  echoS "••••••••••••••••••••••••••••••••••••••••••••••••••••••••"
  echoS ""
  echoS "Site URL: http://${S3_BUCKET}.s3-website.${AWS_REGION}.amazonaws.com"
  echo ""
  if [ "$SILENT_MODE" = true ]; then
    echo "Dist upload successful."
  fi
fi

# If a release version is given
if [ -n "$RELEASE_VERSION" ] ; then
 :
fi

exit 0